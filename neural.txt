-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | BP for FF ANNs
--   
--   BP for FF ANNs
@package neural
@version 0.1.0.0

module Data.Neural.HMatrix.Utility
randomVec :: (MonadRandom m, KnownNat n) => (Double, Double) -> m (R n)
randomMat :: (MonadRandom f, KnownNat n, KnownNat m) => (Double, Double) -> f (L n m)
randomVecMWC :: (PrimMonad m, KnownNat n) => (Double, Double) -> Gen (PrimState m) -> m (R n)
randomMatMWC :: (PrimMonad f, KnownNat n, KnownNat m) => (Double, Double) -> Gen (PrimState f) -> f (L n m)

module Data.Neural.Activation
data NeuralActs :: * -> *
NA :: (a -> a) -> (a -> a) -> NeuralActs a
[naInternal] :: NeuralActs a -> a -> a
[naOuter] :: NeuralActs a -> a -> a
data Activation :: *
IdAct :: Activation
Logistic :: Activation
ReLU :: Activation
LReLU :: !Rational -> Activation
SoftPlus :: Activation
ScaledAct :: !Rational -> !Activation -> Activation
ExpandAct :: !Rational -> !Activation -> Activation
data NASpec :: *
NASpec :: !Activation -> !Activation -> NASpec
reduceAct :: Activation -> Activation
toFunc :: (Floating a, Ord a) => Activation -> a -> a
toFunc' :: (Floating a, Ord a) => Activation -> a -> a
toNeuralActs :: (Floating a, Ord a) => NASpec -> NeuralActs a
toNeuralActs' :: (Floating a, Ord a) => NASpec -> NeuralActs a
logistic :: Floating a => a -> a
relu :: (Num a, Ord a) => a -> a
lRelu :: (Num a, Ord a) => a -> a -> a
softplus :: Floating a => a -> a
naLogId :: Floating a => NeuralActs a
naLogLog :: Floating a => NeuralActs a
naRLId :: (Num a, Ord a) => NeuralActs a
naRLRL :: (Num a, Ord a) => NeuralActs a
naSPId :: Floating a => NeuralActs a
naSPSP :: Floating a => NeuralActs a
naUniform :: (a -> a) -> NeuralActs a
naWithId :: (a -> a) -> NeuralActs a
instance GHC.Generics.Constructor Data.Neural.Activation.C1_0NASpec
instance GHC.Generics.Datatype Data.Neural.Activation.D1NASpec
instance GHC.Generics.Constructor Data.Neural.Activation.C1_6Activation
instance GHC.Generics.Constructor Data.Neural.Activation.C1_5Activation
instance GHC.Generics.Constructor Data.Neural.Activation.C1_4Activation
instance GHC.Generics.Constructor Data.Neural.Activation.C1_3Activation
instance GHC.Generics.Constructor Data.Neural.Activation.C1_2Activation
instance GHC.Generics.Constructor Data.Neural.Activation.C1_1Activation
instance GHC.Generics.Constructor Data.Neural.Activation.C1_0Activation
instance GHC.Generics.Datatype Data.Neural.Activation.D1Activation
instance GHC.Generics.Selector Data.Neural.Activation.S1_0_1NeuralActs
instance GHC.Generics.Selector Data.Neural.Activation.S1_0_0NeuralActs
instance GHC.Generics.Constructor Data.Neural.Activation.C1_0NeuralActs
instance GHC.Generics.Datatype Data.Neural.Activation.D1NeuralActs
instance GHC.Generics.Generic Data.Neural.Activation.NASpec
instance GHC.Read.Read Data.Neural.Activation.NASpec
instance GHC.Classes.Eq Data.Neural.Activation.NASpec
instance GHC.Show.Show Data.Neural.Activation.NASpec
instance GHC.Generics.Generic Data.Neural.Activation.Activation
instance GHC.Read.Read Data.Neural.Activation.Activation
instance GHC.Classes.Eq Data.Neural.Activation.Activation
instance GHC.Show.Show Data.Neural.Activation.Activation
instance GHC.Generics.Generic (Data.Neural.Activation.NeuralActs a)
instance Data.Binary.Class.Binary Data.Neural.Activation.Activation
instance Data.Binary.Class.Binary Data.Neural.Activation.NASpec

module Data.Neural.Types

-- | Types
data Node :: Nat -> * -> *
Node :: !a -> !(V i a) -> Node i a
[nodeBias] :: Node i a -> !a
[nodeWeights] :: Node i a -> !(V i a)
newtype FLayer :: Nat -> Nat -> * -> *
FLayer :: V o (Node i a) -> FLayer i o a
[layerNodes] :: FLayer i o a -> V o (Node i a)
data SomeFLayer :: * -> *
SomeFLayer :: FLayer i o a -> SomeFLayer a
data NetStruct :: *
NetStruct :: Proxy i -> NatList hs -> Proxy o -> NetStruct
type KnownNet i hs o = (KnownNat i, KnownNats hs, KnownNat o)
data NeuralActs :: * -> *
NA :: (a -> a) -> (a -> a) -> NeuralActs a
[naInternal] :: NeuralActs a -> a -> a
[naOuter] :: NeuralActs a -> a -> a
data Activation :: *
IdAct :: Activation
Logistic :: Activation
ReLU :: Activation
LReLU :: !Rational -> Activation
SoftPlus :: Activation
ScaledAct :: !Rational -> !Activation -> Activation
ExpandAct :: !Rational -> !Activation -> Activation
data NASpec :: *
NASpec :: !Activation -> !Activation -> NASpec
tFLayerNodes :: Lens (FLayer i o a) (FLayer i' o' a) (V o (Node i a)) (V o' (Node i' a))
tNodeWeights :: Lens (Node i a) (Node i' a) (V i a) (V i' a)
instance GHC.Generics.Selector Data.Neural.Types.S1_0_0FLayer
instance GHC.Generics.Constructor Data.Neural.Types.C1_0FLayer
instance GHC.Generics.Datatype Data.Neural.Types.D1FLayer
instance GHC.Generics.Selector Data.Neural.Types.S1_0_1Node
instance GHC.Generics.Selector Data.Neural.Types.S1_0_0Node
instance GHC.Generics.Constructor Data.Neural.Types.C1_0Node
instance GHC.Generics.Datatype Data.Neural.Types.D1Node
instance GHC.Generics.Generic (Data.Neural.Types.FLayer a b c)
instance GHC.Base.Functor (Data.Neural.Types.FLayer a b)
instance Data.Traversable.Traversable (Data.Neural.Types.FLayer a b)
instance Data.Foldable.Foldable (Data.Neural.Types.FLayer a b)
instance GHC.Show.Show c => GHC.Show.Show (Data.Neural.Types.FLayer a b c)
instance GHC.Generics.Generic (Data.Neural.Types.Node a b)
instance GHC.Show.Show b => GHC.Show.Show (Data.Neural.Types.Node a b)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, System.Random.Random a) => System.Random.Random (Data.Neural.Types.FLayer i o a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.Types.SomeFLayer a)
instance GHC.Base.Functor Data.Neural.Types.SomeFLayer
instance Data.Foldable.Foldable Data.Neural.Types.SomeFLayer
instance Data.Traversable.Traversable Data.Neural.Types.SomeFLayer
instance (GHC.TypeLits.KnownNat i, System.Random.Random a) => System.Random.Random (Linear.V.V i a)
instance GHC.Base.Functor (Linear.V.V i) => GHC.Base.Functor (Data.Neural.Types.Node i)
instance GHC.Base.Applicative (Linear.V.V i) => GHC.Base.Applicative (Data.Neural.Types.Node i)
instance (GHC.TypeLits.KnownNat i, Linear.Vector.Additive (Linear.V.V i)) => Linear.Vector.Additive (Data.Neural.Types.Node i)
instance (GHC.TypeLits.KnownNat i, Linear.Metric.Metric (Linear.V.V i)) => Linear.Metric.Metric (Data.Neural.Types.Node i)
instance Data.Foldable.Foldable (Data.Neural.Types.Node i)
instance Data.Traversable.Traversable (Data.Neural.Types.Node i)
instance (GHC.TypeLits.KnownNat i, System.Random.Random a) => System.Random.Random (Data.Neural.Types.Node i a)
instance (GHC.TypeLits.KnownNat i, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.Types.Node i a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Types.Node i a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Types.FLayer i o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.Types.FLayer i o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Linear.Vector.Additive (Data.Neural.Types.FLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Base.Applicative (Data.Neural.Types.FLayer i o)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Data.Neural.Types.SomeFLayer a)

module Data.Neural.Utility
unzipV :: V i (a, b) -> (V i a, V i b)
unzipV3 :: V i (a, b, c) -> (V i a, V i b, V i c)
vToR :: KnownNat n => V n Double -> R n
runFLayer :: (KnownNat i, Num a) => FLayer i o a -> V i a -> V o a
foldl'' :: NFData b => (b -> a -> b) -> b -> [a] -> b
netStructVal :: Integer -> [Integer] -> Integer -> Maybe NetStruct
reifyNetStruct :: Integer -> [Integer] -> Integer -> (forall i hs o. (KnownNat i, KnownNat o, KnownNats hs) => Proxy i -> NatList hs -> Proxy o -> r) -> r
fromNetStruct :: NetStruct -> (Integer, [Integer], Integer)
iterateN :: NFData a => (a -> a) -> a -> Int -> a
class Nudges w
nudges :: Nudges w => (a -> a) -> w a -> w (w a)
accumV :: (a -> b -> a) -> V n a -> [(Int, b)] -> V n a
deleteV :: Finite n -> V n a -> V (n - 1) a
snocV :: V n a -> a -> V (n + 1) a
deleteVec :: Int -> Vector a -> Vector a
instance forall (k :: BOX) (n :: k). Linear.V.Dim n => Data.Neural.Utility.Nudges (Linear.V.V n)
instance Linear.V.Dim n => Data.Neural.Utility.Nudges (Data.Neural.Types.Node n)
instance (Linear.V.Dim i, Linear.V.Dim o) => Data.Neural.Utility.Nudges (Data.Neural.Types.FLayer i o)

module Data.Neural.FeedForward
data Network :: Nat -> [Nat] -> Nat -> * -> *
NetOL :: !(FLayer i o a) -> Network i '[] o a
NetIL :: !(FLayer i j a) -> !(Network j hs o a) -> Network i (j : hs) o a
data SomeNet :: * -> *
SomeNet :: Network i hs o a -> SomeNet a
data OpaqueNet :: Nat -> Nat -> * -> *
OpaqueNet :: Network i hs o a -> OpaqueNet i o a
runNetwork :: (KnownNat i, Num a) => (a -> a) -> (a -> a) -> Network i hs o a -> V i a -> V o a
trainSample :: (KnownNat i, KnownNat o, Num a) => a -> (Forward a -> Forward a) -> (Forward a -> Forward a) -> V i a -> V o a -> Network i hs o a -> Network i hs o a
networkHeatmap :: (KnownNat i, Num a) => (a -> a) -> (a -> a) -> Network i hs o a -> V i a -> [[a]]
drawHeatmap :: KnownNat i => (Double -> Double) -> (Double -> Double) -> Network i hs o Double -> V i Double -> String
drawNetwork :: Dim i => Network i hs o Double -> String
randomNetwork :: (RandomGen g, Random (Network i hs o a), Num a) => g -> (Network i hs o a, g)
randomNetworkIO :: (Random (Network i hs o a), Num a) => IO (Network i hs o a)
networkStructure :: (KnownNat i, KnownNat o) => Network i hs o a -> (Int, [Int], Int)

-- | Boilerplate instances
asOpaqueNet :: SomeNet a -> (forall i o. (KnownNat i, KnownNat o) => OpaqueNet i o a -> r) -> r
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.FeedForward.Network i hs o a)
instance Data.Foldable.Foldable (Data.Neural.FeedForward.Network i hs o)
instance Data.Traversable.Traversable (Data.Neural.FeedForward.Network i hs o)
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.FeedForward.SomeNet a)
instance GHC.Base.Functor Data.Neural.FeedForward.SomeNet
instance Data.Foldable.Foldable Data.Neural.FeedForward.SomeNet
instance Data.Traversable.Traversable Data.Neural.FeedForward.SomeNet
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.FeedForward.OpaqueNet i o a)
instance GHC.Base.Functor (Data.Neural.FeedForward.OpaqueNet i o)
instance Data.Foldable.Foldable (Data.Neural.FeedForward.OpaqueNet i o)
instance Data.Traversable.Traversable (Data.Neural.FeedForward.OpaqueNet i o)
instance GHC.Base.Functor (Data.Neural.FeedForward.Network i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Base.Applicative (Data.Neural.FeedForward.Network i '[] o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, GHC.TypeLits.KnownNat j, GHC.Base.Applicative (Data.Neural.FeedForward.Network j hs o)) => GHC.Base.Applicative (Data.Neural.FeedForward.Network i (j : hs) o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, System.Random.Random a) => System.Random.Random (Data.Neural.FeedForward.Network i '[] o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, GHC.TypeLits.KnownNat j, System.Random.Random a, System.Random.Random (Data.Neural.FeedForward.Network j hs o a)) => System.Random.Random (Data.Neural.FeedForward.Network i (j : hs) o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.FeedForward.Network i '[] o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, GHC.TypeLits.KnownNat j, Data.Binary.Class.Binary a, Data.Binary.Class.Binary (Data.Neural.FeedForward.Network j hs o a)) => Data.Binary.Class.Binary (Data.Neural.FeedForward.Network i (j : hs) o a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.FeedForward.Network i hs o a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Data.Neural.FeedForward.SomeNet a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.FeedForward.OpaqueNet i o a)

module Data.Neural.Recurrent
data RNode :: Nat -> Nat -> * -> *
RNode :: !a -> !(V i a) -> !(V s a) -> RNode i s a
[rNodeBias] :: RNode i s a -> !a
[rNodeIWeights] :: RNode i s a -> !(V i a)
[rNodeSWeights] :: RNode i s a -> !(V s a)
data RLayer :: Nat -> Nat -> * -> *
RLayer :: !(V o (RNode i o a)) -> !(V o a) -> RLayer i o a
[rLayerNodes] :: RLayer i o a -> !(V o (RNode i o a))
[rLayerState] :: RLayer i o a -> !(V o a)
data Network :: Nat -> [Nat] -> Nat -> * -> *
NetOL :: !(FLayer i o a) -> Network i '[] o a
NetIL :: !(RLayer i j a) -> !(Network j hs o a) -> Network i (j : hs) o a
data NetActs :: Nat -> [Nat] -> Nat -> * -> *
NetAOL :: !(V o a) -> NetActs i hs o a
NetAIL :: !(V j a) -> !(NetActs j hs o a) -> NetActs i (j : js) o a
data SomeNet :: * -> *
SomeNet :: Network i hs o a -> SomeNet a
data OpaqueNet :: Nat -> Nat -> * -> *
OpaqueNet :: Network i hs o a -> OpaqueNet i o a
runRLayer :: (KnownNat i, KnownNat o, Num a) => (a -> a) -> RLayer i o a -> V i a -> (V o a, RLayer i o a)
runRLayerS :: (KnownNat i, KnownNat o, Num a, MonadState (RLayer i o a) m) => (a -> a) -> V i a -> m (V o a)
netActsOut :: NetActs i hs o a -> V o a
runNetwork :: (Num a, KnownNat i, KnownNat o) => NeuralActs a -> Network i hs o a -> V i a -> (V o a, Network i hs o a)
runNetworkS :: (Num a, KnownNat i, KnownNat o, MonadState (Network i hs o a) m) => NeuralActs a -> V i a -> m (V o a)
runNetworkActs :: (KnownNat i, Num a) => NeuralActs a -> Network i hs o a -> V i a -> (NetActs i hs o a, Network i hs o a)
runNetworkActsS :: (KnownNat i, Num a, MonadState (Network i hs o a) m) => NeuralActs a -> V i a -> m (NetActs i hs o a)
runNetStream :: (Num a, KnownNat i, KnownNat o) => NeuralActs a -> Network i hs o a -> [V i a] -> ([V o a], Network i hs o a)
runNetStream_ :: (Num a, KnownNat i, KnownNat o, NFData a) => NeuralActs a -> Network i hs o a -> [V i a] -> [V o a]
prerunNetStream :: (Num a, KnownNat i, KnownNat o, NFData a) => NeuralActs a -> Network i hs o a -> [V i a] -> Network i hs o a
runNetStreamActs :: (Num a, KnownNat i) => NeuralActs a -> Network i hs o a -> [V i a] -> ([NetActs i hs o a], Network i hs o a)
runNetStreamActs_ :: (Num a, KnownNat i, NFData a) => NeuralActs a -> Network i hs o a -> [V i a] -> [NetActs i hs o a]
runNetFeedback :: (Num a, KnownNat i, KnownNat o) => NeuralActs a -> (V o a -> V i a) -> Network i hs o a -> V i a -> [(V o a, Network i hs o a)]
runNetFeedback_ :: (Num a, KnownNat i, KnownNat o) => NeuralActs a -> (V o a -> V i a) -> Network i hs o a -> V i a -> [V o a]
runNetFeedbackM_ :: (Num a, KnownNat i, Monad m, KnownNat o) => NeuralActs a -> (V o a -> m (V i a)) -> Network i hs o a -> Int -> V i a -> m [V o a]
runNetActsFeedbackM_ :: (Num a, KnownNat i, Monad m, KnownNat o) => NeuralActs a -> (V o a -> m (V i a)) -> Network i hs o a -> Int -> V i a -> m [NetActs i hs o a]
randomNetwork :: (MonadRandom m, Random (Network i hs o a), Num a) => m (Network i hs o a)
randomNetwork' :: (KnownNet i hs o, MonadRandom m, Random (Network i hs o a), Num a) => m (Network i hs o a)
resetNetState :: (KnownNat o, KnownNat i, Num a) => Network i hs o a -> Network i hs o a

-- | Some traversals TODO: sharing with go
tNetRLayers :: (Applicative f, KnownNat o, KnownNat i) => (forall i' o'. (KnownNat i', KnownNat o') => RLayer i' o' a -> f (RLayer i' o' a)) -> Network i hs o a -> f (Network i hs o a)
tRLayerNodes :: Lens (RLayer i o a) (RLayer i' o a) (V o (RNode i o a)) (V o (RNode i' o a))
tRLayerState :: Lens' (RLayer i o a) (V o a)
tNetStates :: (Applicative f, KnownNat o, KnownNat i) => (forall h. KnownNat h => V h a -> f (V h a)) -> Network i hs o a -> f (Network i hs o a)
tNetOLayer :: (Functor f, KnownNat i) => (forall j. KnownNat j => FLayer j o a -> f (FLayer j o' a)) -> Network i hs o a -> f (Network i hs o' a)
tNetLayers :: (Applicative f, KnownNat i) => (forall j. KnownNat j => FLayer j o a -> f (FLayer j o' b)) -> (forall i' j. KnownNat j => RLayer i' j a -> f (RLayer i' j b)) -> Network i hs o a -> f (Network i hs o' b)
tRNodeSWeights :: Lens (RNode i s a) (RNode i s' a) (V s a) (V s' a)
tRNodeIWeights :: Lens (RNode i s a) (RNode i' s a) (V i a) (V i' a)
tRNodeWeights :: Lens' (RNode i s a) (V i a, V s a)

-- | Validating
seriesError :: (KnownNat i, KnownNat o, Num a, Traversable t) => NeuralActs a -> Network i hs o a -> t (V i a, V o a) -> (a, Network i hs o a)
seriesError_ :: (KnownNat i, KnownNat o, Num a, Traversable t) => NeuralActs a -> Network i hs o a -> t (V i a, V o a) -> a
seriesErrorS :: (KnownNat i, KnownNat o, Num a, MonadState (Network i hs o a) m, Traversable t) => NeuralActs a -> t (V i a, V o a) -> m a

-- | Boilerplate instances
asOpaqueNet :: SomeNet a -> (forall i o. (KnownNat i, KnownNat o) => OpaqueNet i o a -> r) -> r
instance GHC.Generics.Selector Data.Neural.Recurrent.S1_0_1RLayer
instance GHC.Generics.Selector Data.Neural.Recurrent.S1_0_0RLayer
instance GHC.Generics.Constructor Data.Neural.Recurrent.C1_0RLayer
instance GHC.Generics.Datatype Data.Neural.Recurrent.D1RLayer
instance GHC.Generics.Selector Data.Neural.Recurrent.S1_0_2RNode
instance GHC.Generics.Selector Data.Neural.Recurrent.S1_0_1RNode
instance GHC.Generics.Selector Data.Neural.Recurrent.S1_0_0RNode
instance GHC.Generics.Constructor Data.Neural.Recurrent.C1_0RNode
instance GHC.Generics.Datatype Data.Neural.Recurrent.D1RNode
instance GHC.Generics.Generic (Data.Neural.Recurrent.RLayer a b c)
instance Data.Traversable.Traversable (Data.Neural.Recurrent.RLayer a b)
instance Data.Foldable.Foldable (Data.Neural.Recurrent.RLayer a b)
instance GHC.Base.Functor (Data.Neural.Recurrent.RLayer a b)
instance GHC.Show.Show c => GHC.Show.Show (Data.Neural.Recurrent.RLayer a b c)
instance Data.Traversable.Traversable (Data.Neural.Recurrent.RNode a b)
instance Data.Foldable.Foldable (Data.Neural.Recurrent.RNode a b)
instance GHC.Generics.Generic (Data.Neural.Recurrent.RNode a b c)
instance GHC.Show.Show c => GHC.Show.Show (Data.Neural.Recurrent.RNode a b c)
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.Recurrent.Network i hs o a)
instance Data.Foldable.Foldable (Data.Neural.Recurrent.Network i hs o)
instance Data.Traversable.Traversable (Data.Neural.Recurrent.Network i hs o)
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.Recurrent.SomeNet a)
instance GHC.Base.Functor Data.Neural.Recurrent.SomeNet
instance Data.Foldable.Foldable Data.Neural.Recurrent.SomeNet
instance Data.Traversable.Traversable Data.Neural.Recurrent.SomeNet
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.Recurrent.OpaqueNet i o a)
instance GHC.Base.Functor (Data.Neural.Recurrent.OpaqueNet i o)
instance Data.Foldable.Foldable (Data.Neural.Recurrent.OpaqueNet i o)
instance Data.Traversable.Traversable (Data.Neural.Recurrent.OpaqueNet i o)
instance GHC.Base.Functor (Data.Neural.Recurrent.RNode i s)
instance (GHC.Base.Applicative (Linear.V.V i), GHC.Base.Applicative (Linear.V.V s)) => GHC.Base.Applicative (Data.Neural.Recurrent.RNode i s)
instance (GHC.TypeLits.KnownNat i, Linear.Vector.Additive (Linear.V.V i), Linear.Vector.Additive (Linear.V.V s)) => Linear.Vector.Additive (Data.Neural.Recurrent.RNode i s)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat s, System.Random.Random a) => System.Random.Random (Data.Neural.Recurrent.RNode i s a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.RNode i s a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat s, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.Recurrent.RNode i s a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.RLayer i o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Base.Applicative (Data.Neural.Recurrent.RLayer i o)
instance (Data.Binary.Class.Binary a, GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Binary.Class.Binary (Data.Neural.Recurrent.RLayer i o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, System.Random.Random a) => System.Random.Random (Data.Neural.Recurrent.RLayer i o a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.NetActs i hs o a)
instance GHC.Base.Functor (Data.Neural.Recurrent.Network i hs o)
instance Data.Neural.Types.KnownNet i hs o => GHC.Base.Applicative (Data.Neural.Recurrent.Network i hs o)
instance GHC.Base.Applicative (Data.Neural.Recurrent.Network i hs o) => Linear.Vector.Additive (Data.Neural.Recurrent.Network i hs o)
instance GHC.Base.Applicative (Data.Neural.Recurrent.Network i hs o) => Linear.Metric.Metric (Data.Neural.Recurrent.Network i hs o)
instance (Data.Neural.Types.KnownNet i hs o, System.Random.Random a) => System.Random.Random (Data.Neural.Recurrent.Network i hs o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.List.KnownNats hs, GHC.TypeLits.KnownNat o, Type.Class.Known.Known (Data.Type.Product.Prod Data.Proxy.Proxy) hs, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.Recurrent.Network i hs o a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.Network i hs o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat s) => Data.Neural.Utility.Nudges (Data.Neural.Recurrent.RNode i s)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Neural.Utility.Nudges (Data.Neural.Recurrent.RLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Neural.Utility.Nudges (Data.Neural.Recurrent.Network i hs o)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Data.Neural.Recurrent.SomeNet a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.Recurrent.OpaqueNet i o a)

module Data.Neural.HMatrix.Recurrent
data FLayer :: Nat -> Nat -> *
FLayer :: !(R o) -> !(L o i) -> FLayer i o
[fLayerBiases] :: FLayer i o -> !(R o)
[fLayerWeights] :: FLayer i o -> !(L o i)
data RLayer :: Nat -> Nat -> *
RLayer :: !(R o) -> !(L o i) -> !(L o o) -> !(R o) -> RLayer i o
[rLayerBiases] :: RLayer i o -> !(R o)
[rLayerIWeights] :: RLayer i o -> !(L o i)
[rLayerSWeights] :: RLayer i o -> !(L o o)
[rLayerState] :: RLayer i o -> !(R o)
data Network :: Nat -> [Nat] -> Nat -> *
NetOL :: !(FLayer i o) -> Network i '[] o
NetIL :: !(RLayer i j) -> !(Network j hs o) -> Network i (j : hs) o
data NetActs :: Nat -> [Nat] -> Nat -> *
NetAOL :: !(R o) -> NetActs i hs o
NetAIL :: !(R j) -> !(NetActs j hs o) -> NetActs i (j : js) o
data SomeNet :: *
SomeNet :: Network i hs o -> SomeNet
data OpaqueNet :: Nat -> Nat -> *
OpaqueNet :: Network i hs o -> OpaqueNet i o
data SomeFLayer :: *
SomeFLayer :: FLayer i o -> SomeFLayer
konstFLayer :: (KnownNat i, KnownNat o) => Double -> FLayer i o
konstRLayer :: (KnownNat i, KnownNat o) => Double -> RLayer i o
pureNet :: KnownNet i hs o => (forall j k. (KnownNat j, KnownNat k) => FLayer j k) -> (forall j k. (KnownNat j, KnownNat k) => RLayer j k) -> Network i hs o
konstNet :: KnownNet i hs o => Double -> Network i hs o
zipNet :: KnownNet i hs o => (forall j k. (KnownNat j, KnownNat k) => FLayer j k -> FLayer j k -> FLayer j k) -> (forall j k. (KnownNat j, KnownNat k) => RLayer j k -> RLayer j k -> RLayer j k) -> Network i hs o -> Network i hs o -> Network i hs o
netActsOut :: NetActs i hs o -> R o
runFLayer :: (KnownNat i, KnownNat o) => FLayer i o -> R i -> R o
runRLayer :: (KnownNat i, KnownNat o) => (Double -> Double) -> RLayer i o -> R i -> (R o, RLayer i o)
runNetwork :: (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> R i -> (R o, Network i hs o)
runNetwork_ :: (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> R i -> R o
runNetworkS :: (KnownNat i, KnownNat o, MonadState (Network i hs o) m) => NeuralActs Double -> R i -> m (R o)
runNetworkActs :: (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> R i -> (NetActs i hs o, Network i hs o)
runNetworkActsS :: (KnownNat i, KnownNat o, MonadState (Network i hs o) m) => NeuralActs Double -> R i -> m (NetActs i hs o)
runNetStream :: (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> [R i] -> ([R o], Network i hs o)
runNetStream_ :: (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> [R i] -> [R o]
runNetStreamActs :: (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> [R i] -> ([NetActs i hs o], Network i hs o)
runNetStreamActs_ :: (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> [R i] -> [NetActs i hs o]
runNetFeedback :: (KnownNat i, KnownNat o) => NeuralActs Double -> (R o -> R i) -> Network i hs o -> R i -> [(R o, Network i hs o)]
runNetFeedback_ :: (KnownNat i, KnownNat o) => NeuralActs Double -> (R o -> R i) -> Network i hs o -> R i -> [R o]
runNetFeedbackM :: (KnownNat i, Monad m, KnownNat o) => NeuralActs Double -> (R o -> m (R i)) -> Network i hs o -> Int -> R i -> m [(R o, Network i hs o)]
runNetFeedbackM_ :: (KnownNat i, Monad m, KnownNat o) => NeuralActs Double -> (R o -> m (R i)) -> Network i hs o -> Int -> R i -> m [R o]
runNetActsFeedback :: (KnownNat i, KnownNat o) => NeuralActs Double -> (R o -> R i) -> Network i hs o -> R i -> [(NetActs i hs o, Network i hs o)]
runNetActsFeedback_ :: (KnownNat i, KnownNat o) => NeuralActs Double -> (R o -> R i) -> Network i hs o -> R i -> [NetActs i hs o]
runNetActsFeedbackM :: (KnownNat i, Monad m, KnownNat o) => NeuralActs Double -> (R o -> m (R i)) -> Network i hs o -> Int -> R i -> m [(NetActs i hs o, Network i hs o)]
runNetActsFeedbackM_ :: (KnownNat i, Monad m, KnownNat o) => NeuralActs Double -> (R o -> m (R i)) -> Network i hs o -> Int -> R i -> m [NetActs i hs o]
fLayerFromHMat :: (KnownNat i, KnownNat o) => FLayer i o -> FLayer i o Double
rLayerFromHMat :: (KnownNat i, KnownNat o) => RLayer i o -> RLayer i o Double
networkFromHMat :: KnownNet i hs o => Network i hs o -> Network i hs o Double
fLayerFromV :: (KnownNat i, KnownNat o) => FLayer i o Double -> FLayer i o
rLayerFromV :: (KnownNat i, KnownNat o) => RLayer i o Double -> RLayer i o
networkFromV :: KnownNet i hs o => Network i hs o Double -> Network i hs o
instance GHC.Generics.Selector Data.Neural.HMatrix.Recurrent.S1_0_3RLayer
instance GHC.Generics.Selector Data.Neural.HMatrix.Recurrent.S1_0_2RLayer
instance GHC.Generics.Selector Data.Neural.HMatrix.Recurrent.S1_0_1RLayer
instance GHC.Generics.Selector Data.Neural.HMatrix.Recurrent.S1_0_0RLayer
instance GHC.Generics.Constructor Data.Neural.HMatrix.Recurrent.C1_0RLayer
instance GHC.Generics.Datatype Data.Neural.HMatrix.Recurrent.D1RLayer
instance GHC.Generics.Selector Data.Neural.HMatrix.Recurrent.S1_0_1FLayer
instance GHC.Generics.Selector Data.Neural.HMatrix.Recurrent.S1_0_0FLayer
instance GHC.Generics.Constructor Data.Neural.HMatrix.Recurrent.C1_0FLayer
instance GHC.Generics.Datatype Data.Neural.HMatrix.Recurrent.D1FLayer
instance GHC.Generics.Generic (Data.Neural.HMatrix.Recurrent.RLayer a b)
instance (GHC.TypeLits.KnownNat a, GHC.TypeLits.KnownNat b) => GHC.Show.Show (Data.Neural.HMatrix.Recurrent.RLayer a b)
instance GHC.Generics.Generic (Data.Neural.HMatrix.Recurrent.FLayer a b)
instance (GHC.TypeLits.KnownNat a, GHC.TypeLits.KnownNat b) => GHC.Show.Show (Data.Neural.HMatrix.Recurrent.FLayer a b)
instance Data.Neural.Types.KnownNet i hs o => GHC.Show.Show (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance Data.Neural.Types.KnownNet i hs o => GHC.Show.Show (Data.Neural.HMatrix.Recurrent.NetActs i hs o)
instance GHC.Show.Show Data.Neural.HMatrix.Recurrent.SomeNet
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Show.Show (Data.Neural.HMatrix.Recurrent.OpaqueNet i o)
instance GHC.Show.Show Data.Neural.HMatrix.Recurrent.SomeFLayer
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.MonoTraversable.MonoFunctor (Data.Neural.HMatrix.Recurrent.FLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.MonoTraversable.MonoFunctor (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Num.Num (Data.Neural.HMatrix.Recurrent.FLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Real.Fractional (Data.Neural.HMatrix.Recurrent.FLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Num.Num (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Real.Fractional (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.List.KnownNats hs, GHC.TypeLits.KnownNat o) => GHC.Num.Num (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.List.KnownNats hs, GHC.TypeLits.KnownNat o) => GHC.Real.Fractional (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.List.KnownNats hs, GHC.TypeLits.KnownNat o) => Data.MonoTraversable.MonoFunctor (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => System.Random.Random (Data.Neural.HMatrix.Recurrent.FLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => System.Random.Random (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance Data.Neural.Types.KnownNet i hs o => System.Random.Random (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.FLayer i o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.NetActs i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Binary.Class.Binary (Data.Neural.HMatrix.Recurrent.FLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Binary.Class.Binary (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance Data.Binary.Class.Binary Data.Neural.HMatrix.Recurrent.SomeFLayer
instance Data.Neural.Types.KnownNet i hs o => Data.Binary.Class.Binary (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance Data.Binary.Class.Binary Data.Neural.HMatrix.Recurrent.SomeNet
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Binary.Class.Binary (Data.Neural.HMatrix.Recurrent.OpaqueNet i o)

module Data.Neural.HMatrix.Recurrent.Train
trainSeries :: KnownNet i hs o => NeuralActs (Forward Double) -> Double -> Double -> R o -> [R i] -> Network i hs o -> Network i hs o
processSeries :: KnownNat n => Vector (a, b) -> Vector (V n a, b)
trainStates :: KnownNet i hs o => Double -> NetworkU i hs o -> NetStates i hs o -> Deltas i hs o -> Network i hs o
bptt :: KnownNet i hs o => NeuralActs (Forward Double) -> Double -> R o -> [R i] -> NetStates i hs o -> NetworkU i hs o -> (Deltas i hs o, NetworkU i hs o)
toNetworkU :: Network i hs o -> (NetStates i hs o, NetworkU i hs o)
data NetworkU :: Nat -> [Nat] -> Nat -> *
NetUOL :: !(FLayer i o) -> NetworkU i '[] o
NetUIL :: !(RLayerU i j) -> !(NetworkU j hs o) -> NetworkU i (j : hs) o
data NetStates :: Nat -> [Nat] -> Nat -> *
NetSOL :: NetStates i '[] o
NetSIL :: !(R j) -> !(NetStates j hs o) -> NetStates i (j : hs) o
instance GHC.Generics.Selector Data.Neural.HMatrix.Recurrent.Train.S1_0_2RLayerU
instance GHC.Generics.Selector Data.Neural.HMatrix.Recurrent.Train.S1_0_1RLayerU
instance GHC.Generics.Selector Data.Neural.HMatrix.Recurrent.Train.S1_0_0RLayerU
instance GHC.Generics.Constructor Data.Neural.HMatrix.Recurrent.Train.C1_0RLayerU
instance GHC.Generics.Datatype Data.Neural.HMatrix.Recurrent.Train.D1RLayerU
instance GHC.Generics.Generic (Data.Neural.HMatrix.Recurrent.Train.RLayerU a b)
instance (GHC.TypeLits.KnownNat a, GHC.TypeLits.KnownNat b) => GHC.Show.Show (Data.Neural.HMatrix.Recurrent.Train.RLayerU a b)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.Train.RLayerU i j)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.Train.NetworkU i hs o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.Train.NetStates i hs o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.Train.Deltas i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Num.Num (Data.Neural.HMatrix.Recurrent.Train.RLayerU i o)
instance Data.Neural.Types.KnownNet i hs o => GHC.Num.Num (Data.Neural.HMatrix.Recurrent.Train.NetworkU i hs o)

module Data.Neural.HMatrix.Recurrent.Dropout
trainSeriesDO :: (KnownNet i hs o, MonadRandom m) => NeuralActs (Forward Double) -> Double -> Double -> Double -> R o -> [R i] -> Network i hs o -> m (Network i hs o)
trainSeriesDOMWC :: (KnownNet i hs o, PrimMonad m) => NeuralActs (Forward Double) -> Double -> Double -> Double -> R o -> [R i] -> Network i hs o -> Gen (PrimState m) -> m (Network i hs o)
compensateDO :: KnownNet i hs o => Double -> Network i hs o -> Network i hs o
instance GHC.Show.Show (Data.Neural.HMatrix.Recurrent.Dropout.NetMask i hs o)

module Data.Neural.HMatrix.Recurrent.Generate
randomFLayer :: (MonadRandom m, KnownNat i, KnownNat o) => (Double, Double) -> m (FLayer i o)
randomRLayer :: (MonadRandom m, KnownNat i, KnownNat o) => (Double, Double) -> m (RLayer i o)
randomNet :: (MonadRandom m, KnownNet i hs o) => (Double, Double) -> m (Network i hs o)
randomFLayerMWC :: (PrimMonad m, KnownNat i, KnownNat o) => (Double, Double) -> Gen (PrimState m) -> m (FLayer i o)
randomRLayerMWC :: (PrimMonad m, KnownNat i, KnownNat o) => (Double, Double) -> Gen (PrimState m) -> m (RLayer i o)
randomNetMWC :: (PrimMonad m, KnownNet i hs o) => (Double, Double) -> Gen (PrimState m) -> m (Network i hs o)

module Data.Neural.HMatrix.Recurrent.Significance
significances :: (KnownNet i hs o) => NeuralActs (Forward Double) -> Network i hs o -> NonEmpty (R i) -> NetSigs i hs o

module Data.Neural.Recurrent.Dropout
compensateDO :: (Num a, KnownNet i hs o) => a -> Network i hs o a -> Network i hs o a

module Data.Neural.Recurrent.Modify
deleteLayer :: KnownNet i hs o => (forall j k. (KnownNat j, KnownNat k) => Node j a -> Node k a) -> (forall j k l. (KnownNat j, KnownNat k, KnownNat l) => RNode j l a -> RNode k l a) -> Fin (Len hs) -> Network i hs o a -> OpaqueNet i o a
addLayer :: (KnownNet i hs o, KnownNat l) => (forall j k. (KnownNat j, KnownNat k) => (RLayer j l a, FLayer l k a)) -> (forall j k. (KnownNat j, KnownNat k) => (RLayer j l a, RLayer l k a)) -> Fin (Len (i : hs)) -> Network i hs o a -> OpaqueNet i o a
deleteNode :: KnownNet i hs o => Index hs h -> Finite h -> Network i hs o a -> OpaqueNet i o a
addNode :: KnownNet i hs o => (forall j l. (KnownNat j, KnownNat l, KnownNat (l + 1)) => (RNode j (l + 1) a, V l a, a)) -> (forall k. KnownNat k => V k a) -> Fin (Len hs) -> Network i hs o a -> OpaqueNet i o a

module Data.Neural.Recurrent.Train
newtype RLayerU :: Nat -> Nat -> * -> *
RLayerU :: (V o (RNode i o a)) -> RLayerU i o a
[rLayerUNodes] :: RLayerU i o a -> (V o (RNode i o a))
data NetworkU :: Nat -> [Nat] -> Nat -> * -> *
NetUOL :: !(FLayer i o a) -> NetworkU i '[] o a
NetUIL :: !(RLayerU i j a) -> !(NetworkU j hs o a) -> NetworkU i (j : hs) o a
data Deltas :: Nat -> [Nat] -> Nat -> * -> *
DeltasOL :: !(V i a) -> Deltas i '[] o a
DeltasIL :: !(V i a) -> !(V j a) -> !(Deltas j hs o a) -> Deltas i (j : hs) o a
data NetStates :: Nat -> [Nat] -> Nat -> * -> *
NetSOL :: NetStates i '[] o a
NetSIL :: !(V j a) -> !(NetStates j hs o a) -> NetStates i (j : hs) o a
runRLayerU :: (KnownNat i, KnownNat o, Num a) => (a -> a) -> RLayerU i o a -> V i a -> V o a -> (V o a, V o a)
runNetworkU :: (Num a, KnownNat i) => NeuralActs a -> NetworkU i hs o a -> V i a -> NetStates i hs o a -> (V o a, NetStates i hs o a)
tNetULayers :: (Applicative f) => (forall j. FLayer j o a -> f (FLayer j o' b)) -> (forall i' j. RLayerU i' j a -> f (RLayerU i' j b)) -> NetworkU i hs o a -> f (NetworkU i hs o' b)
toNetworkU :: Network i hs o a -> (NetStates i hs o a, NetworkU i hs o a)
trainSeries :: (KnownNet i hs o, Fractional a, NFData a) => NeuralActs (Forward a) -> a -> a -> V o a -> [V i a] -> Network i hs o a -> Network i hs o a

-- | Stochastic
nudgeNetworkN :: (MonadRandom m, Floating a, Random (Network i hs o a), Applicative (Network i hs o)) => a -> Network i hs o a -> m (Network i hs o a)
nudgeNetwork :: (MonadRandom m, Num a, Random a) => a -> Network i hs o a -> m (Network i hs o a)
adjustNetwork :: (MonadRandom m, MonadState (Network i hs o a) m, Random a, Ord a, Floating a, KnownNat i, KnownNat o) => NeuralActs a -> (Network i hs o a -> m (Network i hs o a)) -> a -> Maybe a -> [(V i a, V o a)] -> m a
adjustNetworkGD :: (Applicative (Network i hs o), Floating a, KnownNat i, KnownNat o, Show a) => NeuralActs a -> a -> a -> [(V i a, V o a)] -> Network i hs o a -> Network i hs o a
trainSeriesSI :: (MonadRandom m, MonadState (Network i hs o a) m, Floating a, Ord a, KnownNat i, KnownNat o, Random a) => NeuralActs a -> (Network i hs o a -> m (Network i hs o a)) -> a -> a -> [(V i a, V o a)] -> Int -> m ()
trainSeriesGD :: (Floating a, KnownNet i hs o, Random a, Show a, NFData a) => NeuralActs a -> a -> a -> [(V i a, V o a)] -> Network i hs o a -> Int -> Network i hs o a
instance GHC.Generics.Selector Data.Neural.Recurrent.Train.S1_0_0RLayerU
instance GHC.Generics.Constructor Data.Neural.Recurrent.Train.C1_0RLayerU
instance GHC.Generics.Datatype Data.Neural.Recurrent.Train.D1RLayerU
instance GHC.Generics.Generic (Data.Neural.Recurrent.Train.RLayerU a b c)
instance Data.Traversable.Traversable (Data.Neural.Recurrent.Train.RLayerU a b)
instance Data.Foldable.Foldable (Data.Neural.Recurrent.Train.RLayerU a b)
instance GHC.Base.Functor (Data.Neural.Recurrent.Train.RLayerU a b)
instance GHC.Show.Show c => GHC.Show.Show (Data.Neural.Recurrent.Train.RLayerU a b c)
instance GHC.Base.Functor (Data.Neural.Recurrent.Train.NetworkU i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Base.Applicative (Data.Neural.Recurrent.Train.RLayerU i o)
instance Data.Neural.Types.KnownNet i hs o => GHC.Base.Applicative (Data.Neural.Recurrent.Train.NetworkU i hs o)
instance GHC.Base.Applicative (Data.Neural.Recurrent.Train.NetworkU i hs o) => Linear.Vector.Additive (Data.Neural.Recurrent.Train.NetworkU i hs o)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.Train.NetworkU i hs o a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.Train.RLayerU i j a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.Train.NetStates i hs o a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.Train.Deltas i hs o a)
